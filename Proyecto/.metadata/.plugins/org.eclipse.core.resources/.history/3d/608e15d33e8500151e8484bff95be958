package spacemans_adventures_interface;

public class list { // Clase para la creación de una lista de nodos.

//-----> DECLARACIÓN DE LOS ATRIBUTOS DE LA CLASE.
	
	// Inicialización de los atributos.
	public list_node first; // Atributo para crear una referencia al primer nodo de la lista. 

	  // a list is created in an empty state
	  public list() { // Constructor.

	    first = null; // Inicializamos la lista en un estado vacío.
	  }

	  public void insert(node o) { // Método para insertar nodos en la lista.

	  	list_node nuevo = new list_node(o, first); // Creamos un nuevo nodo que tendrá como referencia al first anterior.
	    first = nuevo; // Establecemos el nuevo first.
	  }

	  public node extract() { // Método para extraer un nodo de la lista.

	    node out = null; // Creamos una variable local en la que almacenaremos el nodo que saquemos.

	    if (isEmpty() == false) { // CONDICIÓN: Si en la lista hay algún nodo (first != null).
	      out = first.getInfo(); // Almacenamos en out el nodo a extraer.
	      first = first.getNext(); // El first de dicho nodo, será ahora el first del siguiente, ya que este nodo se extrae.
	    }
	    
	    return out; // Retornamos el nodo extraído. Si la lista está vacía, se retorna null.
	  }

	  public boolean empty() { // Método boleano para comprobar si la lista está vacía.
	    if (first == null) { // CONDICIÓN: Si el first es igual a null (no hay ningún nodo en la lista).
	      return true; // Retornamos true.
	    }
	    else {
	      return false; // Retornamos false. 
	    }
	  }

	  public int lenght() { // Método que devuelve la cantidad de nodos de la lista.

	    int contador = 0; // Variable local para ir contando el número de nodos.
	    list_node nodoaux = first; // Variable local para almacenar un nodo auxiliar que será el nodo de comienzo.

	    while(nodoaux != null) { // Mientras la referecencia al nodo auxiliar no sea igual a null (fin de la lista).
	      contador++; // Aumentamos en uno la variable contador.
	      nodoaux = nodoaux.getNext(); // Establecemos el nodo auxiliar como el siguiente nodo.
	    }

	    return contador; // Retornamos la variable contador.
	  }

	  public void Ordenar() { // Método para implementar el algoritmo de la burbuja y ordenar la lista.
		  
	  	list_node actual; // Variable local para el primer nodo de la comparación.
	  	list_node siguiente; // Variable local para el segundo nodo de la comparación.
	  	node aux; // Variable local de un nodo auxiliar usado en la comparación.
	  	actual = first; // Inicializamos el nodo actual en el principio de la lista.

	  	while(actual != null) { // Mientras el nodo actual no sea igual a null.
	  		siguiente = actual.getNext(); // Almacenamos en siguente el nodo situado justo después del actual.
	  		while(siguiente != null) { // Mientras el nodo siguiente no sea igual a null.
	  			if(actual.getInfo().get_f() > siguiente.getInfo().get_f()) { // CONDICIÓN: Si el valor del nodo actual es mayor que el del nodo siguiente.
	  				aux = actual.getInfo(); // Almacenamos en el nodo auxiliar el valor del siguiente para conservarla.
	  				actual.setInfo(siguiente.getInfo()); // Establecemos como valor del nodo actual la información del nodo siguiente.
	  				siguiente.setInfo(aux); // Establecemos como valor del nodo siguiente la información del auxiliar (anteriormente la de actual).
	  			}
	  		siguiente = siguiente.getNext(); // Establecemos como al nodo siguiente que está justo después del siguiente usado en el if.
	  		}
	  		actual = actual.getNext(); // Establecemos como nodo actual al que está justo después del actual usado.
	  	}
	  }

	  public boolean find(node nodo){ // Método boleano para encontrar un nodo dentro de la lista.

	  	list_node nodoactual = first; // Variable local que almacenará el nodo actual. Iniciada en el primer nodo.

	  	while (nodoactual != null){ // Mientras el nodo actual no sea igual a null.
	  		if(nodoactual.getInfo().es_igual(nodo)) { // Llamada al método es_igual(), que comprueba si la información de los nodos coinciden.
	  			return true; // Retornamos true para establecer que se ha encontrado el nodo en la lista.
	  		}
	  		else {
	  			nodoactual= nodoactual.getNext(); // Establecemos como nodo actual al que esta justo después.
	  		}
	  	}
	  	return false; // Si terminamos de recorrer la lista y no encontramos ningún nodo coincidente, retornamos false.
	  }
}
